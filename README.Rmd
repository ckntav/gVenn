---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# gVenn

<!-- badges: start -->
![Maintainer](https://img.shields.io/badge/maintainer-ckntav-blue)
![Last commit](https://img.shields.io/github/last-commit/ckntav/gVenn)
<!-- badges: end -->
<img align="right" src="man/figures/20250827_hex_gVenn_v1.png" width="175"/>

**Proportional Venn diagrams for genomic regions and gene set overlaps**

**gVenn** stands for **gene/genomic Venn**.  
It provides tools to compute overlaps between genomic regions or sets of genes
and visualize them as Venn diagrams with areas proportional to the number of 
overlapping elements. With seamless support for `GRanges` and `GRangesList` 
objects, **gVenn** integrates naturally into Bioconductor workflows such as 
ChIP-seq, ATAC-seq, or other interval-based analyses, and produces clean, 
publication-ready figures.

<img src="man/figures/20250827_graphical_abstract_v2.png" align="center" width="800"/>

## Installation

You can install the development version of gVenn from [GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("ckntav/gVenn")
```

## Quick start

This quick example demonstrates how to compute overlaps between ChIP-seq 
peaks and visualize them with both a Venn diagram and an UpSet plot.

### 1. Load example ChIP-seq data and compute overlaps
```{r, example_ov}
library(gVenn)

# Example dataset of ChIP-seq peaks (A549 cell line, 3 genomic regions)
data(a549_chipseq_peaks)

# Compute overlaps
ov <- computeOverlaps(a549_chipseq_peaks)
```

### 2. Visualize
```{r, example_venn}
# Draw Venn diagram
plotVenn(ov)
```

```{r, example_upset, fig.width=5, fig.height=2.5}
# Draw UpSet plot (useful for larger numbers of sets)
plotUpSet(ov)
```

### 3. Extract elements per overlap group
```{r, extractOverlaps_example1}
groups <- extractOverlaps(ov)
```
```{r, extractOverlaps_example2}
# Display the number of genomic regions per overlap group
sapply(groups, length)
```

#### Overlap group naming
When overlaps are computed, each group of elements or genomic regions is
labeled with a binary code that indicates which sets the element belongs to.

 - Each digit in the code corresponds to one input set (e.g., A, B, C).
 - A 1 means the element is present in that set, while 0 means absent.
 - The group names in the output are prefixed with "group_" for clarity.

<div align="center">
| Group name   | Meaning                       |
|--------------|-------------------------------|
| `group_100`  | Elements only in **A**        |
| `group_010`  | Elements only in **B**        |
| `group_001`  | Elements only in **C**        |
| `group_110`  | Elements in **A ∩ B** (not C) |
| `group_101`  | Elements in **A ∩ C** (not B) |
| `group_011`  | Elements in **B ∩ C** (not A) |
| `group_111`  | Elements in **A ∩ B ∩ C**     |
</div>

#### Extract one particular group
Each overlap group can be accessed directly by name for downstream analyses,
including motif enrichment, transcription factor (TF) enrichment, annotation of
peaks to nearby genes, functional enrichment or visualization.

For example, to extract all elements that are present in **A ∩ B ∩ C**:

```{r, extractOverlaps_example3}
# Extract elements in group_111 (present in A, B, and C)
peaks_in_all_sets <- groups[["group_111"]]

# Display the elements
peaks_in_all_sets
```

## Contributing

Pull requests are welcome. If you find a bug, have a suggestion, or want to
add a feature, please open an issue first to discuss what you would like
to change.
